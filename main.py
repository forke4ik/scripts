import logging
import os
import asyncio
import aiohttp
import json
from datetime import datetime
from pathlib import Path
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, BotCommand
from telegram.ext import Application, CommandHandler, ContextTypes, CallbackQueryHandler
from quart import Quart, request, Response

# TOKEN –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è Render
TOKEN = os.environ.get("TOKEN")
CREATOR_ID = 7106925462  # ID —Å–æ–∑–¥–∞—Ç–µ–ª—è –±–æ—Ç–∞

# –ó–∞–º–µ–Ω–∏ –Ω–∞ —Å—Å—ã–ª–∫—É –Ω–∞ —Ç–≤–æ–π –∑–∞–∫—Ä—ã—Ç—ã–π –∫–∞–Ω–∞–ª
CHANNEL_LINK = "https://t.me/+57Wq6w2wbYhkNjYy"
WEBHOOK_PATH = "webhook"

# URL –¥–ª—è —Å–∞–º–æ–ø–∏–Ω–≥–∞ (–∑–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ –≤–∞—à –∞–∫—Ç—É–∞–ª—å–Ω—ã–π URL)
SELF_PING_URL = "https://my-telegram-webhook-bot.onrender.com"
PING_INTERVAL = 600  # 10 –º–∏–Ω—É—Ç

# –ü—É—Ç—å –∫ —Ñ–∞–π–ª—É —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
STATS_FILE = "stats.json"

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', 
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# –ì–ª–æ–±–∞–ª—å–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–ª—è –∑–∞–¥–∞—á–∏ –ø–∏–Ω–≥–∞
ping_task = None

# --- –°–∏—Å—Ç–µ–º–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ ---
def load_stats():
    """–ó–∞–≥—Ä—É–∂–∞–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∏–∑ —Ñ–∞–π–ª–∞"""
    try:
        if Path(STATS_FILE).exists():
            with open(STATS_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
    except Exception as e:
        logger.error(f"Error loading stats: {e}")
    return {
        "total_users": 0,
        "link_clicks": 0,
        "users": {}
    }

def save_stats(stats):
    """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –≤ —Ñ–∞–π–ª"""
    try:
        with open(STATS_FILE, 'w', encoding='utf-8') as f:
            json.dump(stats, f, indent=2, ensure_ascii=False)
    except Exception as e:
        logger.error(f"Error saving stats: {e}")

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
stats = load_stats()

async def setup_menu(application: Application):
    """–£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –º–µ–Ω—é –∫–æ–º–∞–Ω–¥ –≤ –±–æ—Ç–µ"""
    commands = [
        BotCommand("start", "–ù–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É —Å –±–æ—Ç–æ–º"),
        BotCommand("help", "–ü–æ–º–æ—â—å –ø–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é –±–æ—Ç–∞"),
        BotCommand("channel", "–ü–æ–ª—É—á–∏—Ç—å —Å—Å—ã–ª–∫—É –Ω–∞ –∫–∞–Ω–∞–ª"),
    ]
    await application.bot.set_my_commands(commands)
    logger.info("–ú–µ–Ω—é –∫–æ–º–∞–Ω–¥ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ")

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É /start –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å—Å—ã–ª–∫—É —Å –∫–ª–∞–≤–∏–∞—Ç—É—Ä–æ–π."""
    global stats
    user = update.effective_user
    logger.info(f"Received /start command from user {user.id}")
    
    # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
    user_id_str = str(user.id)
    if user_id_str not in stats['users']:
        stats['total_users'] += 1
        stats['users'][user_id_str] = {
            "id": user.id,
            "username": user.username,
            "first_name": user.first_name,
            "last_name": user.last_name,
            "start_time": datetime.now().isoformat(),
            "link_clicks": 0
        }
        save_stats(stats)
    
    # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å –∫–Ω–æ–ø–∫–æ–π
    keyboard = [
        [InlineKeyboardButton("–ó–∞–π—Ç–∏ –≤ –∫–∞–Ω–∞–ª", url=CHANNEL_LINK)]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    try:
        await update.message.reply_html(
            f"–ü—Ä–∏–≤–µ—Ç, {user.mention_html()}! –Ø –ø–æ–º–æ–≥—É —Ç–µ–±–µ –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –Ω–∞—à–µ–º—É –∑–∞–∫—Ä—ã—Ç–æ–º—É –∫–∞–Ω–∞–ª—É.",
            reply_markup=reply_markup
        )
        logger.info(f"Sent /start response to user {user.id}")
    except Exception as e:
        logger.error(f"Error sending /start response to user {user.id}: {e}")

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É /help"""
    help_text = (
        "ü§ñ <b>–ö–æ–º–∞–Ω–¥—ã –±–æ—Ç–∞:</b>\n\n"
        "/start - –ù–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É —Å –±–æ—Ç–æ–º\n"
        "/help - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç—É —Å–ø—Ä–∞–≤–∫—É\n"
        "/channel - –ü–æ–ª—É—á–∏—Ç—å —Å—Å—ã–ª–∫—É –Ω–∞ –∫–∞–Ω–∞–ª\n"
        "\n"
        "–ü—Ä–æ—Å—Ç–æ –Ω–∞–∂–º–∏ –Ω–∞ –∫–Ω–æ–ø–∫—É <b>¬´–ó–∞–π—Ç–∏ –≤ –∫–∞–Ω–∞–ª¬ª</b>, —á—Ç–æ–±—ã –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è –∫ –Ω–∞—à–µ–º—É —Å–æ–æ–±—â–µ—Å—Ç–≤—É!"
    )
    await update.message.reply_html(help_text)

async def channel_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É /channel"""
    keyboard = [
        [InlineKeyboardButton("–ó–∞–π—Ç–∏ –≤ –∫–∞–Ω–∞–ª", url=CHANNEL_LINK)]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(
        "–ù–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ, —á—Ç–æ–±—ã –ø–µ—Ä–µ–π—Ç–∏ –≤ –Ω–∞—à –∑–∞–∫—Ä—ã—Ç—ã–π –∫–∞–Ω–∞–ª:",
        reply_markup=reply_markup
    )

async def track_link_click(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """–û—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç –Ω–∞–∂–∞—Ç–∏—è –Ω–∞ –∫–Ω–æ–ø–∫—É (–¥–ª—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏)"""
    query = update.callback_query
    await query.answer()
    logger.info(f"Button clicked by user {query.from_user.id}")
    
    # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–µ—Ä–µ—Ö–æ–¥–æ–≤
    user_id_str = str(query.from_user.id)
    global stats
    
    if user_id_str in stats['users']:
        stats['users'][user_id_str]['link_clicks'] += 1
        stats['link_clicks'] += 1
        save_stats(stats)
        logger.info(f"Updated link click stats for user {query.from_user.id}")
    else:
        logger.warning(f"User {query.from_user.id} clicked but not in stats")

async def stats_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Å–æ–∑–¥–∞—Ç–µ–ª—é –±–æ—Ç–∞"""
    user = update.effective_user
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞ –¥–æ—Å—Ç—É–ø–∞
    if user.id != CREATOR_ID:
        await update.message.reply_text("‚õî –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã.")
        return
    
    global stats
    message = (
        f"üìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–æ—Ç–∞:</b>\n\n"
        f"üë§ –í—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: <b>{stats['total_users']}</b>\n"
        f"üñ±Ô∏è –ü–µ—Ä–µ—Ö–æ–¥–æ–≤ –ø–æ —Å—Å—ã–ª–∫–µ: <b>{stats['link_clicks']}</b>\n"
        f"üïí –ü–æ—Å–ª–µ–¥–Ω–µ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
    )
    
    try:
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç–æ–≤—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
        await update.message.reply_html(message)
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ñ–∞–π–ª —Å –ø–æ–ª–Ω–æ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–æ–π
        with open(STATS_FILE, 'rb') as f:
            await update.message.reply_document(
                document=f,
                filename='bot_stats.json',
                caption="–ü–æ–ª–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –≤ JSON"
            )
        logger.info(f"Sent stats to creator {user.id}")
    except Exception as e:
        logger.error(f"Error sending stats: {e}")
        await update.message.reply_text(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏: {e}")

async def self_ping():
    """–§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–∞–º–æ–ø–∏–Ω–≥–∞ —Å–µ—Ä–≤–µ—Ä–∞"""
    while True:
        try:
            await asyncio.sleep(PING_INTERVAL)
            
            timeout = aiohttp.ClientTimeout(total=30)
            async with aiohttp.ClientSession(timeout=timeout) as session:
                timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                logger.info(f"üì° –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–∞–º–æ–ø–∏–Ω–≥ –≤ {timestamp}")
                
                async with session.get(f"{SELF_PING_URL}/") as response:
                    if response.status == 200:
                        data = await response.json()
                        logger.info(f"‚úÖ –°–∞–º–æ–ø–∏–Ω–≥ —É—Å–ø–µ—à–µ–Ω: {data.get('status', 'OK')}")
                    else:
                        logger.warning(f"‚ö†Ô∏è –°–∞–º–æ–ø–∏–Ω–≥ –≤–µ—Ä–Ω—É–ª —Å—Ç–∞—Ç—É—Å {response.status}")
                        
        except asyncio.CancelledError:
            logger.info("üõë –°–∞–º–æ–ø–∏–Ω–≥ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
            break
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Å–∞–º–æ–ø–∏–Ω–≥–∞: {e}")

# --- –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–±—ä–µ–∫—Ç–∞ Application –∏–∑ python-telegram-bot ---
if not TOKEN:
    logger.error("Error: Bot TOKEN not found in environment variables!")
    raise ValueError("Bot TOKEN not set")

logger.info("Creating Application object...")
telegram_application = Application.builder().token(TOKEN).build()
logger.info("Application object created.")

logger.info("Adding command handlers...")
telegram_application.add_handler(CommandHandler("start", start))
telegram_application.add_handler(CommandHandler("help", help_command))
telegram_application.add_handler(CommandHandler("channel", channel_command))
telegram_application.add_handler(CommandHandler("stats", stats_command))
telegram_application.add_handler(CallbackQueryHandler(track_link_click))
logger.info("Command handlers added.")

# --- –ù–∞—Å—Ç—Ä–æ–π–∫–∞ Quart –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è (ASGI —Å–æ–≤–º–µ—Å—Ç–∏–º—ã–π) ---
app = Quart(__name__)
logger.info("Quart app created.")

# –§–ª–∞–≥ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ Application
is_application_initialized = False

@app.before_serving
async def startup():
    """–ó–∞–ø—É—Å–∫–∞–µ—Ç—Å—è –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è"""
    global ping_task
    logger.info("üöÄ –ó–∞–ø—É—Å–∫ —Å–∞–º–æ–ø–∏–Ω–≥–∞...")
    ping_task = asyncio.create_task(self_ping())
    
    # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –º–µ–Ω—é –∫–æ–º–∞–Ω–¥
    logger.info("–£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –º–µ–Ω—é –∫–æ–º–∞–Ω–¥...")
    await setup_menu(telegram_application)

@app.after_serving
async def shutdown():
    """–ó–∞–ø—É—Å–∫–∞–µ—Ç—Å—è –ø—Ä–∏ –æ—Å—Ç–∞–Ω–æ–≤–∫–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è"""
    global ping_task
    if ping_task:
        logger.info("üõë –û—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å–∞–º–æ–ø–∏–Ω–≥–∞...")
        ping_task.cancel()
        try:
            await ping_task
        except asyncio.CancelledError:
            pass

@app.route(f"/{WEBHOOK_PATH}", methods=["POST"])
async def telegram_webhook_handler():
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤—Ö–æ–¥—è—â–∏–µ –∑–∞–ø—Ä–æ—Å—ã –æ—Ç –¢–µ–ª–µ–≥—Ä–∞–º–∞."""
    global is_application_initialized
    logger.info("Received POST request on /webhook")

    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º Application, –µ—Å–ª–∏ —ç—Ç–æ –µ—â–µ –Ω–µ —Å–¥–µ–ª–∞–Ω–æ
    if not is_application_initialized:
        logger.info("Initializing Application...")
        try:
            await telegram_application.initialize()
            is_application_initialized = True
            logger.info("Application initialized.")
        except Exception as e:
            logger.error(f"Error during Application initialization: {e}")
            return Response(status=500)

    update_json = await request.get_json()
    if not update_json:
        logger.warning("Received empty webhook request")
        return Response(status=400)

    logger.info("Received update JSON, attempting to parse...")
    try:
        update = Update.de_json(update_json, telegram_application.bot)
        logger.info(f"Update parsed: {update.update_id}")
    except Exception as e:
         logger.error(f"Error parsing update JSON: {e}")
         return Response(status=400)

    # --- –ü–µ—Ä–µ–¥–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ Application –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ ---
    logger.info(f"Processing update {update.update_id} using application.process_update...")
    try:
        await telegram_application.process_update(update)
        logger.info(f"Update {update.update_id} processing finished.")
    except Exception as e:
        logger.error(f"Error processing update {update.update_id} in Application: {e}")
        pass

    # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—Ç–≤–µ—Ç –¢–µ–ª–µ–≥—Ä–∞–º—É
    logger.info("Returning 200 OK to Telegram")
    return Response(status=200)

# –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –∫–æ—Ä–Ω–µ–≤–æ–≥–æ –ø—É—Ç–∏
@app.route("/", methods=["GET"])
async def health_check():
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è —Å–µ—Ä–≤–µ—Ä–∞."""
    return {
        "status": "Bot is running", 
        "webhook_url": f"/{WEBHOOK_PATH}",
        "ping_status": "active" if ping_task and not ping_task.done() else "inactive",
        "timestamp": datetime.now().isoformat(),
        "stats": {
            "total_users": stats['total_users'],
            "link_clicks": stats['link_clicks']
        }
    }

# –î–æ–±–∞–≤–ª—è–µ–º –º–∞—Ä—à—Ä—É—Ç –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ webhook
@app.route("/set_webhook", methods=["GET"])
async def set_webhook():
    """–£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç webhook –¥–ª—è –±–æ—Ç–∞."""
    webhook_url = f"{SELF_PING_URL}/webhook"
    
    try:
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º Application –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
        global is_application_initialized
        if not is_application_initialized:
            await telegram_application.initialize()
            is_application_initialized = True
        
        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º webhook
        await telegram_application.bot.set_webhook(webhook_url)
        logger.info(f"Webhook set to: {webhook_url}")
        return {"status": "success", "webhook_url": webhook_url}
    except Exception as e:
        logger.error(f"Error setting webhook: {e}")
        return {"status": "error", "error": str(e)}

# –î–æ–±–∞–≤–ª—è–µ–º –º–∞—Ä—à—Ä—É—Ç –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ç–∞—Ç—É—Å–∞ –ø–∏–Ω–≥–∞
@app.route("/ping_status", methods=["GET"])
async def ping_status():
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç–∞—Ç—É—Å –ø–∏–Ω–≥–∞"""
    return {
        "ping_active": ping_task and not ping_task.done(),
        "ping_interval": PING_INTERVAL,
        "self_ping_url": SELF_PING_URL,
        "timestamp": datetime.now().isoformat()
    }

# --- –î–ª—è uvicorn ---
# app —É–∂–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω –∫–∞–∫ Quart –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ —è–≤–ª—è–µ—Ç—Å—è ASGI —Å–æ–≤–º–µ—Å—Ç–∏–º—ã–º

logger.info("ASGI application ready.")
